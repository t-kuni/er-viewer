// Client-side logging system
class ClientLogger {
    static sendLog(level, message, error = null) {
        const logData = {
            level,
            message,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            userAgent: navigator.userAgent
        };
        
        if (error && error.stack) {
            logData.stack = error.stack;
            logData.line = error.line || error.lineno;
            logData.column = error.column || error.colno;
        }
        
        fetch('/api/logs', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(logData)
        }).catch(err => console.warn('Failed to send log to server:', err));
    }
    
    static info(message) {
        console.log(message);
        this.sendLog('info', message);
    }
    
    static warn(message) {
        console.warn(message);
        this.sendLog('warn', message);
    }
    
    static error(message, error = null) {
        console.error(message, error);
        this.sendLog('error', message, error);
    }
}

// Override console methods to capture all logs
const originalLog = console.log;
const originalWarn = console.warn;
const originalError = console.error;

console.log = function(...args) {
    originalLog.apply(console, args);
    ClientLogger.sendLog('info', args.join(' '));
};

console.warn = function(...args) {
    originalWarn.apply(console, args);
    ClientLogger.sendLog('warn', args.join(' '));
};

console.error = function(...args) {
    originalError.apply(console, args);
    ClientLogger.sendLog('error', args.join(' '));
};

// Global error handler
window.addEventListener('error', (event) => {
    ClientLogger.sendLog('error', `${event.message}`, {
        stack: event.error ? event.error.stack : '',
        line: event.lineno,
        column: event.colno,
        filename: event.filename
    });
});

// Unhandled promise rejection handler
window.addEventListener('unhandledrejection', (event) => {
    ClientLogger.sendLog('error', `Unhandled promise rejection: ${event.reason}`, {
        stack: event.reason && event.reason.stack ? event.reason.stack : ''
    });
});

class ERViewer {
    constructor() {
        this.canvas = document.getElementById('er-canvas');
        this.sidebar = document.getElementById('sidebar');
        this.sidebarContent = document.getElementById('sidebar-content');
        
        this.erData = null;
        this.layoutData = { entities: {}, rectangles: [], texts: [] };
        this.scale = 1;
        this.panX = 0;
        this.panY = 0;
        this.isDragging = false;
        this.dragTarget = null;
        this.dragOffset = { x: 0, y: 0 };
        this.isPanning = false;
        this.selectedAnnotation = null;
        this.isResizing = false;
        this.resizeHandle = null;
        this.resizeTarget = null;
        this.lastPanPoint = { x: 0, y: 0 };
        
        this.initEventListeners();
        this.loadERData();
    }

    initEventListeners() {
        document.getElementById('reverse-btn').addEventListener('click', () => this.reverseEngineer());
        document.getElementById('save-btn').addEventListener('click', () => this.saveLayout());
        document.getElementById('load-btn').addEventListener('click', () => this.loadERData());
        document.getElementById('close-sidebar').addEventListener('click', () => this.closeSidebar());
        document.getElementById('add-rectangle-btn').addEventListener('click', () => this.addRectangle());
        document.getElementById('add-text-btn').addEventListener('click', () => this.addText());
        document.getElementById('build-info-btn').addEventListener('click', () => this.showBuildInfo());
        document.getElementById('close-build-info-modal').addEventListener('click', () => this.hideBuildInfo());
        
        // Close modal when clicking outside
        document.getElementById('build-info-modal').addEventListener('click', (e) => {
            if (e.target.id === 'build-info-modal') {
                this.hideBuildInfo();
            }
        });

        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('click', (e) => this.handleClick(e));
        this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
        this.canvas.addEventListener('contextmenu', (e) => this.handleContextMenu(e));
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                this.canvas.style.cursor = 'grab';
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                this.deleteSelectedAnnotation();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                this.canvas.style.cursor = 'default';
            }
        });
    }

    async loadERData() {
        try {
            console.log('Loading ER data...');
            const response = await fetch('/api/er-data');
            if (response.ok) {
                this.erData = await response.json();
                this.layoutData = this.erData.layout || { entities: {}, rectangles: [], texts: [] };
                console.log('ER data loaded successfully:', this.erData);
                this.renderER();
            } else {
                console.warn(`Failed to load ER data: ${response.status} ${response.statusText}`);
            }
        } catch (error) {
            console.error('Error loading ER data:', error);
        }
    }

    async reverseEngineer() {
        console.log('Starting reverse engineering...');
        this.showLoading('リバースエンジニアリング中...');
        try {
            const response = await fetch('/api/reverse-engineer', { method: 'POST' });
            if (response.ok) {
                this.erData = await response.json();
                this.layoutData = this.erData.layout || { entities: {}, rectangles: [], texts: [] };
                
                // Clear existing positions to force clustering
                this.erData.entities.forEach(entity => {
                    entity.position = null;
                });
                
                // Reset clustering cache to force recalculation
                this.relationshipClusters = null;
                
                console.log('Reverse engineering completed successfully');
                this.renderER();
            } else {
                const errorText = await response.text();
                console.error(`Reverse engineering failed: ${response.status} ${response.statusText}`, errorText);
                this.showError('リバースエンジニアリングに失敗しました', `${response.status}: ${errorText}`);
            }
        } catch (error) {
            console.error('Error during reverse engineering:', error);
            this.showError('リバースエンジニアリング中にエラーが発生しました', error.message);
        } finally {
            this.hideLoading();
        }
    }

    async saveLayout() {
        try {
            const response = await fetch('/api/layout', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(this.layoutData)
            });
            if (response.ok) {
                this.showSuccess('レイアウトを保存しました');
            } else {
                this.showError('レイアウトの保存に失敗しました');
            }
        } catch (error) {
            console.error('Error saving layout:', error);
            this.showError('レイアウト保存中にエラーが発生しました', error.message);
        }
    }

    renderER() {
        if (!this.erData) return;

        const svg = this.canvas;
        svg.innerHTML = svg.innerHTML.split('<defs>')[0] + '<defs>' + svg.innerHTML.split('</defs>')[1];

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('id', 'main-group');
        g.setAttribute('transform', `translate(${this.panX}, ${this.panY}) scale(${this.scale})`);
        svg.appendChild(g);

        this.renderRelationships(g);
        this.renderCustomElements(g);
        this.renderEntities(g);
    }

    updateTransform() {
        const mainGroup = document.getElementById('main-group');
        if (mainGroup) {
            mainGroup.setAttribute('transform', `translate(${this.panX}, ${this.panY}) scale(${this.scale})`);
        }
    }

    renderEntities(container) {
        this.erData.entities.forEach((entity, index) => {
            const position = entity.position || this.calculateClusteredPosition(entity, index);
            
            const entityGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            entityGroup.setAttribute('class', 'entity');
            entityGroup.setAttribute('data-table', entity.name);
            entityGroup.setAttribute('transform', `translate(${position.x}, ${position.y})`);

            const width = 180;
            const headerHeight = 30;
            const rowHeight = 20;
            const bottomPadding = 8;
            const height = headerHeight + entity.columns.length * rowHeight + bottomPadding;

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('class', 'entity-rect');
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            entityGroup.appendChild(rect);

            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('class', 'entity-title');
            title.setAttribute('x', width / 2);
            title.setAttribute('y', headerHeight / 2);
            title.textContent = entity.name;
            entityGroup.appendChild(title);

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', 0);
            line.setAttribute('y1', headerHeight);
            line.setAttribute('x2', width);
            line.setAttribute('y2', headerHeight);
            line.setAttribute('stroke', '#34495e');
            line.setAttribute('stroke-width', 1);
            entityGroup.appendChild(line);

            entity.columns.forEach((column, colIndex) => {
                const columnText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                columnText.setAttribute('class', `entity-column column ${column.key === 'PRI' ? 'primary-key' : ''} ${(entity.foreignKeys || []).some(fk => fk.column === column.name) ? 'foreign-key' : ''}`);
                columnText.setAttribute('data-column', column.name);
                columnText.setAttribute('x', 10);
                columnText.setAttribute('y', headerHeight + (colIndex + 1) * rowHeight - 5);
                columnText.textContent = `${column.name}: ${column.type}`;
                entityGroup.appendChild(columnText);
            });

            container.appendChild(entityGroup);
        });
    }

    renderRelationships(container) {
        this.erData.relationships.forEach(rel => {
            const fromEntity = this.erData.entities.find(e => e.name === rel.from);
            const toEntity = this.erData.entities.find(e => e.name === rel.to);
            
            if (!fromEntity || !toEntity) return;

            // Calculate optimal connection points on entity edges using column information
            const fromBounds = this.getEntityBounds(fromEntity);
            const toBounds = this.getEntityBounds(toEntity);
            const connectionPoints = this.findOptimalConnectionPoints(fromBounds, toBounds, rel);

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('class', 'relationship');
            path.setAttribute('data-from', rel.from);
            path.setAttribute('data-to', rel.to);
            path.setAttribute('data-from-column', rel.fromColumn);
            path.setAttribute('data-to-column', rel.toColumn);
            
            const pathData = this.createPolylinePath(connectionPoints.from, connectionPoints.to);
            path.setAttribute('d', pathData);
            
            container.appendChild(path);
        });
    }

    renderCustomElements(container) {
        this.layoutData.rectangles.forEach((rect, index) => {
            // Create group for rectangle and resize handles
            const rectGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            rectGroup.setAttribute('class', 'rectangle-group');

            const rectElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rectElement.setAttribute('class', 'custom-rectangle');
            rectElement.setAttribute('x', rect.x);
            rectElement.setAttribute('y', rect.y);
            rectElement.setAttribute('width', rect.width);
            rectElement.setAttribute('height', rect.height);
            rectElement.setAttribute('data-type', 'rectangle');
            rectElement.setAttribute('data-index', index);
            if (rect.stroke) {
                rectElement.style.stroke = rect.stroke;
                console.log(`Setting stroke for rectangle ${index}:`, rect.stroke);
            }
            if (rect.fill) {
                rectElement.style.fill = rect.fill;
                console.log(`Setting fill for rectangle ${index}:`, rect.fill);
            }
            rectGroup.appendChild(rectElement);

            // Add resize handles when selected
            if (this.selectedAnnotation && 
                this.selectedAnnotation.getAttribute('data-index') == index && 
                this.selectedAnnotation.getAttribute('data-type') === 'rectangle') {
                this.addResizeHandles(rectGroup, rect, index);
                // Update selected annotation reference to new element
                this.selectedAnnotation = rectElement;
                rectElement.classList.add('selected');
            }

            container.appendChild(rectGroup);
        });

        this.layoutData.texts.forEach((text, index) => {
            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textElement.setAttribute('class', 'custom-text');
            textElement.setAttribute('x', text.x);
            textElement.setAttribute('y', text.y);
            textElement.setAttribute('data-type', 'text');
            textElement.setAttribute('data-index', index);
            if (text.color) textElement.setAttribute('fill', text.color);
            if (text.size) textElement.setAttribute('font-size', text.size);
            textElement.textContent = text.content;
            container.appendChild(textElement);
        });
    }

    createPolylinePath(from, to) {
        const path = this.findSmartPath(from, to);
        return this.pathPointsToSVG(path);
    }

    findSmartPath(from, to) {
        const entityBounds = this.getAllEntityBounds();
        
        // Try direct L-shaped path first
        const directPath = this.createLShapedPath(from, to);
        if (!this.pathIntersectsEntities(directPath, entityBounds)) {
            return directPath;
        }

        // If direct path intersects, find alternative route
        return this.findAlternativePath(from, to, entityBounds);
    }

    createLShapedPath(from, to) {
        const midX = (from.x + to.x) / 2;
        return [
            { x: from.x, y: from.y },
            { x: midX, y: from.y },
            { x: midX, y: to.y },
            { x: to.x, y: to.y }
        ];
    }

    findAlternativePath(from, to, entityBounds) {
        // Try different routing strategies
        const strategies = [
            () => this.routeAroundEntities(from, to, entityBounds, 'horizontal'),
            () => this.routeAroundEntities(from, to, entityBounds, 'vertical'),
            () => this.routeWithOffset(from, to, entityBounds, 50),
            () => this.routeWithOffset(from, to, entityBounds, -50)
        ];

        for (const strategy of strategies) {
            const path = strategy();
            if (path && !this.pathIntersectsEntities(path, entityBounds)) {
                return path;
            }
        }

        // Fallback to simple L-shaped path if no smart route found
        return this.createLShapedPath(from, to);
    }

    routeAroundEntities(from, to, entityBounds, direction) {
        const padding = 20;
        
        if (direction === 'horizontal') {
            // Route horizontally first, then vertically around obstacles
            const intermediateY = from.y;
            const clearX = this.findClearHorizontalPath(from.x, to.x, intermediateY, entityBounds, padding);
            
            return [
                { x: from.x, y: from.y },
                { x: clearX, y: from.y },
                { x: clearX, y: to.y },
                { x: to.x, y: to.y }
            ];
        } else {
            // Route vertically first, then horizontally around obstacles
            const intermediateX = from.x;
            const clearY = this.findClearVerticalPath(from.y, to.y, intermediateX, entityBounds, padding);
            
            return [
                { x: from.x, y: from.y },
                { x: from.x, y: clearY },
                { x: to.x, y: clearY },
                { x: to.x, y: to.y }
            ];
        }
    }

    routeWithOffset(from, to, entityBounds, offset) {
        const midX = (from.x + to.x) / 2 + offset;
        const midY = (from.y + to.y) / 2 + offset;
        
        return [
            { x: from.x, y: from.y },
            { x: midX, y: from.y },
            { x: midX, y: midY },
            { x: to.x, y: midY },
            { x: to.x, y: to.y }
        ];
    }

    findClearHorizontalPath(startX, endX, y, entityBounds, padding) {
        const minX = Math.min(startX, endX);
        const maxX = Math.max(startX, endX);
        
        // Check for entities that intersect with the horizontal line
        for (const bounds of entityBounds) {
            if (y >= bounds.top - padding && y <= bounds.bottom + padding &&
                bounds.left <= maxX + padding && bounds.right >= minX - padding) {
                // Entity blocks the path, route around it
                if (startX < endX) {
                    return bounds.right + padding;
                } else {
                    return bounds.left - padding;
                }
            }
        }
        
        return (startX + endX) / 2;
    }

    findClearVerticalPath(startY, endY, x, entityBounds, padding) {
        const minY = Math.min(startY, endY);
        const maxY = Math.max(startY, endY);
        
        // Check for entities that intersect with the vertical line
        for (const bounds of entityBounds) {
            if (x >= bounds.left - padding && x <= bounds.right + padding &&
                bounds.top <= maxY + padding && bounds.bottom >= minY - padding) {
                // Entity blocks the path, route around it
                if (startY < endY) {
                    return bounds.bottom + padding;
                } else {
                    return bounds.top - padding;
                }
            }
        }
        
        return (startY + endY) / 2;
    }

    getAllEntityBounds() {
        if (!this.erData || !this.erData.entities) return [];
        
        return this.erData.entities.map(entity => {
            return this.getEntityBounds(entity);
        });
    }

    getEntityBounds(entity) {
        const pos = entity.position || { x: 50, y: 50 };
        const headerHeight = 30;
        const rowHeight = 20;
        const bottomPadding = 8;
        const width = 180;
        const height = headerHeight + entity.columns.length * rowHeight + bottomPadding;
        
        return {
            left: pos.x,
            top: pos.y,
            right: pos.x + width,
            bottom: pos.y + height,
            centerX: pos.x + width / 2,
            centerY: pos.y + height / 2,
            width: width,
            height: height
        };
    }

    findOptimalConnectionPoints(fromBounds, toBounds, relationship) {
        // If column information is available, use column-level connection points
        if (relationship && relationship.fromColumn && relationship.toColumn) {
            return this.getColumnConnectionPoints(fromBounds, toBounds, relationship);
        }
        
        // Fallback to entity-level connection points
        return this.getEntityConnectionPoints(fromBounds, toBounds);
    }

    getColumnConnectionPoints(fromBounds, toBounds, relationship) {
        const fromColumnPoint = this.getColumnPosition(fromBounds, relationship.from, relationship.fromColumn);
        const toColumnPoint = this.getColumnPosition(toBounds, relationship.to, relationship.toColumn);
        
        if (!fromColumnPoint || !toColumnPoint) {
            // Fallback to entity-level points if column positions can't be determined
            return this.getEntityConnectionPoints(fromBounds, toBounds);
        }
        
        // Determine which side of the entity to connect from/to based on column positions
        const fromConnectionPoint = this.getColumnConnectionPoint(fromBounds, fromColumnPoint, toBounds);
        const toConnectionPoint = this.getColumnConnectionPoint(toBounds, toColumnPoint, fromBounds);
        
        return {
            from: fromConnectionPoint,
            to: toConnectionPoint
        };
    }

    getColumnPosition(entityBounds, entityName, columnName) {
        // Find the entity in the data
        const entity = this.erData.entities.find(e => e.name === entityName);
        if (!entity) return null;
        
        // Find the column index
        const columnIndex = entity.columns.findIndex(col => col.name === columnName);
        if (columnIndex === -1) return null;
        
        // Calculate column position within the entity
        const headerHeight = 30;
        const rowHeight = 20;
        const columnY = entityBounds.top + headerHeight + (columnIndex + 1) * rowHeight - rowHeight/2;
        
        return {
            x: entityBounds.centerX,
            y: columnY,
            columnIndex: columnIndex
        };
    }

    getColumnConnectionPoint(entityBounds, columnPosition, targetBounds) {
        const margin = 5;
        
        // Determine which side to connect from based on target position
        const toTargetCenter = targetBounds.centerX - entityBounds.centerX;
        
        if (toTargetCenter > 0) {
            // Target is to the right, connect from right edge
            return {
                x: entityBounds.right + margin,
                y: columnPosition.y
            };
        } else {
            // Target is to the left, connect from left edge
            return {
                x: entityBounds.left - margin,
                y: columnPosition.y
            };
        }
    }

    getEntityConnectionPoints(fromBounds, toBounds) {
        // Get edge points for both entities
        const fromEdges = this.getEntityEdgePoints(fromBounds);
        const toEdges = this.getEntityEdgePoints(toBounds);
        
        // Find the closest edge points
        let bestDistance = Infinity;
        let bestFromPoint = fromEdges.right;
        let bestToPoint = toEdges.left;
        
        for (const fromEdge of Object.values(fromEdges)) {
            for (const toEdge of Object.values(toEdges)) {
                const distance = Math.sqrt(
                    Math.pow(toEdge.x - fromEdge.x, 2) + 
                    Math.pow(toEdge.y - fromEdge.y, 2)
                );
                
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestFromPoint = fromEdge;
                    bestToPoint = toEdge;
                }
            }
        }
        
        return {
            from: bestFromPoint,
            to: bestToPoint
        };
    }

    getEntityEdgePoints(bounds) {
        const margin = 5; // Small margin from the exact edge for visual clarity
        
        return {
            top: { x: bounds.centerX, y: bounds.top - margin },
            bottom: { x: bounds.centerX, y: bounds.bottom + margin },
            left: { x: bounds.left - margin, y: bounds.centerY },
            right: { x: bounds.right + margin, y: bounds.centerY }
        };
    }

    pathIntersectsEntities(pathPoints, entityBounds) {
        if (!pathPoints || pathPoints.length < 2) return false;
        
        for (let i = 0; i < pathPoints.length - 1; i++) {
            const start = pathPoints[i];
            const end = pathPoints[i + 1];
            
            for (const bounds of entityBounds) {
                if (this.lineIntersectsRectangle(start, end, bounds)) {
                    return true;
                }
            }
        }
        
        return false;
    }

    lineIntersectsRectangle(start, end, rect) {
        // Check if line segment intersects with rectangle
        return (
            this.lineIntersectsLine(start, end, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.top}) ||
            this.lineIntersectsLine(start, end, {x: rect.right, y: rect.top}, {x: rect.right, y: rect.bottom}) ||
            this.lineIntersectsLine(start, end, {x: rect.right, y: rect.bottom}, {x: rect.left, y: rect.bottom}) ||
            this.lineIntersectsLine(start, end, {x: rect.left, y: rect.bottom}, {x: rect.left, y: rect.top}) ||
            this.pointInRectangle(start, rect) ||
            this.pointInRectangle(end, rect)
        );
    }

    lineIntersectsLine(p1, p2, p3, p4) {
        const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
        if (denom === 0) return false;
        
        const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
        const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;
        
        return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
    }

    pointInRectangle(point, rect) {
        return point.x >= rect.left && point.x <= rect.right && 
               point.y >= rect.top && point.y <= rect.bottom;
    }

    pathPointsToSVG(pathPoints) {
        if (!pathPoints || pathPoints.length === 0) return '';
        
        let path = `M ${pathPoints[0].x} ${pathPoints[0].y}`;
        for (let i = 1; i < pathPoints.length; i++) {
            path += ` L ${pathPoints[i].x} ${pathPoints[i].y}`;
        }
        return path;
    }

    calculateClusteredPosition(entity, index) {
        // If this is the initial load and all entities are at default position, apply clustering
        if (this.shouldApplyInitialClustering()) {
            return this.getInitialClusteredPosition(entity, index);
        }
        
        // Fallback to grid layout for single entities
        return { x: 50 + (index % 4) * 200, y: 50 + Math.floor(index / 4) * 150 };
    }

    shouldApplyInitialClustering() {
        if (!this.erData || !this.erData.entities) return false;
        
        // Always apply clustering on initial reverse engineering
        return true;
    }

    getInitialClusteredPosition(entity, index) {
        if (!this.relationshipClusters) {
            this.relationshipClusters = this.buildRelationshipClusters();
        }
        
        const cluster = this.findEntityCluster(entity.name);
        return this.calculateClusterPosition(cluster, entity.name);
    }

    buildRelationshipClusters() {
        const clusters = [];
        const processedEntities = new Set();
        
        // Build connected components based on relationships
        this.erData.entities.forEach(entity => {
            if (processedEntities.has(entity.name)) return;
            
            const cluster = this.findConnectedEntities(entity.name, processedEntities);
            if (cluster.length > 0) {
                clusters.push(cluster);
            }
        });
        
        // Sort clusters by size (larger clusters get better positions)
        clusters.sort((a, b) => b.length - a.length);
        
        return clusters;
    }

    findConnectedEntities(startEntity, processedEntities, visited = new Set()) {
        if (visited.has(startEntity) || processedEntities.has(startEntity)) {
            return [];
        }
        
        visited.add(startEntity);
        processedEntities.add(startEntity);
        
        const cluster = [startEntity];
        
        // Find all directly connected entities
        const relationships = this.erData.relationships || [];
        const connectedEntities = new Set();
        
        relationships.forEach(rel => {
            if (rel.from === startEntity && !visited.has(rel.to)) {
                connectedEntities.add(rel.to);
            } else if (rel.to === startEntity && !visited.has(rel.from)) {
                connectedEntities.add(rel.from);
            }
        });
        
        // Recursively find all entities in this connected component
        connectedEntities.forEach(connectedEntity => {
            cluster.push(...this.findConnectedEntities(connectedEntity, processedEntities, visited));
        });
        
        return cluster;
    }

    findEntityCluster(entityName) {
        if (!this.relationshipClusters) return null;
        
        for (let i = 0; i < this.relationshipClusters.length; i++) {
            if (this.relationshipClusters[i].includes(entityName)) {
                return { index: i, entities: this.relationshipClusters[i] };
            }
        }
        
        return null;
    }

    calculateClusterPosition(cluster, entityName) {
        if (!cluster) {
            // Single entity with no relationships - place in available space
            return this.findAvailableSpace();
        }
        
        const clusterIndex = cluster.index;
        const entityIndex = cluster.entities.indexOf(entityName);
        
        // Calculate cluster base position
        const clustersPerRow = 2;
        const clusterSpacing = { x: 600, y: 400 };
        const baseX = 100 + (clusterIndex % clustersPerRow) * clusterSpacing.x;
        const baseY = 100 + Math.floor(clusterIndex / clustersPerRow) * clusterSpacing.y;
        
        // Arrange entities within cluster using force-directed approach
        return this.calculateEntityPositionInCluster(cluster.entities, entityName, baseX, baseY);
    }

    calculateEntityPositionInCluster(clusterEntities, entityName, baseX, baseY) {
        const entityIndex = clusterEntities.indexOf(entityName);
        
        if (clusterEntities.length === 1) {
            return { x: baseX, y: baseY };
        }
        
        // For small clusters, use predefined patterns
        if (clusterEntities.length <= 4) {
            return this.getSmallClusterPosition(entityIndex, clusterEntities.length, baseX, baseY);
        }
        
        // For larger clusters, use circular arrangement
        return this.getCircularClusterPosition(entityIndex, clusterEntities.length, baseX, baseY);
    }

    getSmallClusterPosition(entityIndex, clusterSize, baseX, baseY) {
        const spacing = 220; // Space between entities
        
        switch (clusterSize) {
            case 2:
                return entityIndex === 0 
                    ? { x: baseX, y: baseY }
                    : { x: baseX + spacing, y: baseY };
            
            case 3:
                const trianglePositions = [
                    { x: baseX, y: baseY },
                    { x: baseX + spacing, y: baseY },
                    { x: baseX + spacing/2, y: baseY + spacing * 0.866 }
                ];
                return trianglePositions[entityIndex];
            
            case 4:
                const squarePositions = [
                    { x: baseX, y: baseY },
                    { x: baseX + spacing, y: baseY },
                    { x: baseX, y: baseY + spacing },
                    { x: baseX + spacing, y: baseY + spacing }
                ];
                return squarePositions[entityIndex];
            
            default:
                return { x: baseX, y: baseY };
        }
    }

    getCircularClusterPosition(entityIndex, clusterSize, baseX, baseY) {
        const radius = Math.max(150, clusterSize * 30);
        const angle = (entityIndex / clusterSize) * 2 * Math.PI;
        
        return {
            x: baseX + radius * Math.cos(angle),
            y: baseY + radius * Math.sin(angle)
        };
    }

    findAvailableSpace() {
        // Find space not occupied by clusters
        const occupiedSpaces = this.relationshipClusters ? this.relationshipClusters.length : 0;
        const clustersPerRow = 2;
        const clusterSpacing = { x: 600, y: 400 };
        
        const x = 100 + (occupiedSpaces % clustersPerRow) * clusterSpacing.x + 300;
        const y = 100 + Math.floor(occupiedSpaces / clustersPerRow) * clusterSpacing.y;
        
        return { x, y };
    }

    handleWheel(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        this.scale = Math.max(0.1, Math.min(3, this.scale * delta));
        this.updateTransform();
    }

    handleMouseDown(e) {
        const resizeHandle = e.target.closest('.resize-handle');
        const target = e.target.closest('.entity, .custom-rectangle, .custom-text');

        if (resizeHandle) {
            e.preventDefault();
            this.isResizing = true;
            this.resizeHandle = resizeHandle;
            this.resizeTarget = {
                index: parseInt(resizeHandle.getAttribute('data-rect-index')),
                type: resizeHandle.getAttribute('data-handle-type')
            };
            const rect = this.canvas.getBoundingClientRect();
            this.dragOffset = this.screenToSVG(e.clientX - rect.left, e.clientY - rect.top);
            return;
        }
        
        if (e.button === 1 || (e.button === 0 && e.code === 'Space')) {
            this.isPanning = true;
            this.lastPanPoint = { x: e.clientX, y: e.clientY };
            this.canvas.style.cursor = 'grabbing';
        } else if (target) {
            this.isDragging = true;
            this.dragTarget = target;
            const rect = this.canvas.getBoundingClientRect();
            const svgPoint = this.screenToSVG(e.clientX - rect.left, e.clientY - rect.top);
            
            if (target.classList.contains('entity')) {
                const transform = target.getAttribute('transform');
                const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                if (match) {
                    this.dragOffset = {
                        x: svgPoint.x - parseFloat(match[1]),
                        y: svgPoint.y - parseFloat(match[2])
                    };
                }
            } else if (target.classList.contains('custom-rectangle')) {
                const x = parseFloat(target.getAttribute('x'));
                const y = parseFloat(target.getAttribute('y'));
                this.dragOffset = {
                    x: svgPoint.x - x,
                    y: svgPoint.y - y
                };
            } else if (target.classList.contains('custom-text')) {
                const x = parseFloat(target.getAttribute('x'));
                const y = parseFloat(target.getAttribute('y'));
                this.dragOffset = {
                    x: svgPoint.x - x,
                    y: svgPoint.y - y
                };
            }
        }
    }

    handleMouseMove(e) {
        if (this.isPanning) {
            const dx = e.clientX - this.lastPanPoint.x;
            const dy = e.clientY - this.lastPanPoint.y;
            this.panX += dx;
            this.panY += dy;
            this.lastPanPoint = { x: e.clientX, y: e.clientY };
            this.updateTransform();
        } else if (this.isResizing && this.resizeTarget) {
            const rect = this.canvas.getBoundingClientRect();
            const svgPoint = this.screenToSVG(e.clientX - rect.left, e.clientY - rect.top);
            this.handleResize(svgPoint);
        } else if (this.isDragging && this.dragTarget) {
            const rect = this.canvas.getBoundingClientRect();
            const svgPoint = this.screenToSVG(e.clientX - rect.left, e.clientY - rect.top);
            
            if (this.dragTarget.classList.contains('entity')) {
                const newX = svgPoint.x - this.dragOffset.x;
                const newY = svgPoint.y - this.dragOffset.y;
                this.dragTarget.setAttribute('transform', `translate(${newX}, ${newY})`);
                
                const tableName = this.dragTarget.getAttribute('data-table');
                if (tableName) {
                    if (!this.layoutData.entities[tableName]) {
                        this.layoutData.entities[tableName] = {};
                    }
                    this.layoutData.entities[tableName].position = { x: newX, y: newY };
                    
                    const entity = this.erData.entities.find(e => e.name === tableName);
                    if (entity) {
                        entity.position = { x: newX, y: newY };
                    }
                }
            } else if (this.dragTarget.classList.contains('custom-rectangle')) {
                const newX = svgPoint.x - this.dragOffset.x;
                const newY = svgPoint.y - this.dragOffset.y;
                this.dragTarget.setAttribute('x', newX);
                this.dragTarget.setAttribute('y', newY);
                
                const index = parseInt(this.dragTarget.getAttribute('data-index'));
                if (this.layoutData.rectangles[index]) {
                    this.layoutData.rectangles[index].x = newX;
                    this.layoutData.rectangles[index].y = newY;
                }
            } else if (this.dragTarget.classList.contains('custom-text')) {
                const newX = svgPoint.x - this.dragOffset.x;
                const newY = svgPoint.y - this.dragOffset.y;
                this.dragTarget.setAttribute('x', newX);
                this.dragTarget.setAttribute('y', newY);
                
                const index = parseInt(this.dragTarget.getAttribute('data-index'));
                if (this.layoutData.texts[index]) {
                    this.layoutData.texts[index].x = newX;
                    this.layoutData.texts[index].y = newY;
                }
            }
        } else {
            const target = e.target.closest('.entity, .relationship');
            this.clearHighlights();
            
            if (target) {
                if (target.classList.contains('entity')) {
                    this.highlightEntity(target.getAttribute('data-table'));
                } else if (target.classList.contains('relationship')) {
                    this.highlightRelationshipColumns(target);
                }
            }
        }
    }

    handleMouseUp(e) {
        const wasEntityDragging = this.isDragging && this.dragTarget && this.dragTarget.classList.contains('entity');
        
        this.isDragging = false;
        this.dragTarget = null;
        this.isPanning = false;
        this.isResizing = false;
        this.resizeHandle = null;
        this.resizeTarget = null;
        this.canvas.style.cursor = 'default';
        
        // エンティティドラッグ完了時のみリレーション線を再描画
        if (wasEntityDragging) {
            this.renderER();
        }
    }

    handleClick(e) {
        const entity = e.target.closest('.entity');
        if (entity) {
            const tableName = entity.getAttribute('data-table');
            this.showTableDetails(tableName);
        }
    }

    handleDoubleClick(e) {
        const textElement = e.target.closest('.custom-text');
        if (textElement) {
            const index = parseInt(textElement.getAttribute('data-index'));
            this.editText(index, textElement);
        }
    }

    handleContextMenu(e) {
        const annotation = e.target.closest('.custom-rectangle, .custom-text');
        if (annotation) {
            e.preventDefault();
            this.selectAnnotation(annotation);
            this.showContextMenu(e.clientX, e.clientY);
        }
    }

    selectAnnotation(element) {
        // Clear previous selection
        if (this.selectedAnnotation) {
            this.selectedAnnotation.classList.remove('selected');
        }
        
        // Select new annotation
        this.selectedAnnotation = element;
        element.classList.add('selected');
    }

    showContextMenu(x, y) {
        // Remove existing context menu
        const existing = document.getElementById('context-menu');
        if (existing) {
            existing.remove();
        }

        // Create context menu
        const menu = document.createElement('div');
        menu.id = 'context-menu';
        menu.style.position = 'fixed';
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.style.backgroundColor = '#ffffff';
        menu.style.border = '1px solid #ccc';
        menu.style.borderRadius = '4px';
        menu.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
        menu.style.zIndex = '2000';
        menu.style.minWidth = '120px';

        // Add edit properties option for rectangles
        if (this.selectedAnnotation && this.selectedAnnotation.classList.contains('custom-rectangle')) {
            const editItem = document.createElement('div');
            editItem.textContent = 'プロパティ編集';
            editItem.style.padding = '8px 12px';
            editItem.style.cursor = 'pointer';
            editItem.style.borderRadius = '4px';
            editItem.addEventListener('mouseenter', () => {
                editItem.style.backgroundColor = '#f0f0f0';
            });
            editItem.addEventListener('mouseleave', () => {
                editItem.style.backgroundColor = 'transparent';
            });
            editItem.addEventListener('click', () => {
                this.editRectangleProperties();
                menu.remove();
            });

            menu.appendChild(editItem);
        }

        // Add edit properties option for text
        if (this.selectedAnnotation && this.selectedAnnotation.classList.contains('custom-text')) {
            const editItem = document.createElement('div');
            editItem.textContent = 'プロパティ編集';
            editItem.style.padding = '8px 12px';
            editItem.style.cursor = 'pointer';
            editItem.style.borderRadius = '4px';
            editItem.addEventListener('mouseenter', () => {
                editItem.style.backgroundColor = '#f0f0f0';
            });
            editItem.addEventListener('mouseleave', () => {
                editItem.style.backgroundColor = 'transparent';
            });
            editItem.addEventListener('click', () => {
                this.editTextProperties();
                menu.remove();
            });

            menu.appendChild(editItem);
        }

        const deleteItem = document.createElement('div');
        deleteItem.textContent = '削除';
        deleteItem.style.padding = '8px 12px';
        deleteItem.style.cursor = 'pointer';
        deleteItem.style.borderRadius = '4px';
        deleteItem.addEventListener('mouseenter', () => {
            deleteItem.style.backgroundColor = '#f0f0f0';
        });
        deleteItem.addEventListener('mouseleave', () => {
            deleteItem.style.backgroundColor = 'transparent';
        });
        deleteItem.addEventListener('click', () => {
            this.deleteSelectedAnnotation();
            menu.remove();
        });

        menu.appendChild(deleteItem);
        document.body.appendChild(menu);

        // Remove menu when clicking elsewhere
        const removeMenu = (e) => {
            if (!menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener('click', removeMenu);
            }
        };
        setTimeout(() => {
            document.addEventListener('click', removeMenu);
        }, 0);
    }

    deleteSelectedAnnotation() {
        if (!this.selectedAnnotation) return;

        const type = this.selectedAnnotation.getAttribute('data-type');
        const index = parseInt(this.selectedAnnotation.getAttribute('data-index'));

        if (type === 'rectangle') {
            this.layoutData.rectangles.splice(index, 1);
        } else if (type === 'text') {
            this.layoutData.texts.splice(index, 1);
        }

        this.selectedAnnotation = null;
        this.renderER();

        // Remove context menu if exists
        const menu = document.getElementById('context-menu');
        if (menu) {
            menu.remove();
        }
    }

    editRectangleProperties() {
        if (!this.selectedAnnotation || !this.selectedAnnotation.classList.contains('custom-rectangle')) return;

        const index = parseInt(this.selectedAnnotation.getAttribute('data-index'));
        const rect = this.layoutData.rectangles[index];
        if (!rect) return;

        // Create properties modal
        const modal = document.createElement('div');
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
        modal.style.zIndex = '3000';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';

        const dialog = document.createElement('div');
        dialog.style.backgroundColor = '#ffffff';
        dialog.style.padding = '20px';
        dialog.style.borderRadius = '8px';
        dialog.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
        dialog.style.minWidth = '300px';

        dialog.innerHTML = `
            <h3 style="margin: 0 0 20px 0;">矩形のプロパティ</h3>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">線の色:</label>
                <input type="color" id="stroke-color" value="${rect.stroke || '#3498db'}" style="width: 100%; height: 40px;">
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">塗りつぶしの色:</label>
                <input type="color" id="fill-color" value="${this.extractColorFromFill(rect.fill) || '#3498db'}" style="width: 100%; height: 40px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px;">透明度:</label>
                <input type="range" id="opacity" min="0" max="100" value="${this.extractOpacityFromFill(rect.fill) || 10}" style="width: 100%;">
                <span id="opacity-value">${this.extractOpacityFromFill(rect.fill) || 10}%</span>
            </div>
            <div style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; font-size: 14px; color: #666;">
                サイズ変更: 矩形を選択して端をドラッグしてください
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="cancel-btn" style="padding: 8px 16px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">キャンセル</button>
                <button id="save-btn" style="padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">保存</button>
            </div>
        `;

        modal.appendChild(dialog);
        document.body.appendChild(modal);

        // Opacity slider handler
        const opacitySlider = dialog.querySelector('#opacity');
        const opacityValue = dialog.querySelector('#opacity-value');
        opacitySlider.addEventListener('input', (e) => {
            opacityValue.textContent = e.target.value + '%';
        });

        // Button handlers
        dialog.querySelector('#cancel-btn').addEventListener('click', () => {
            document.body.removeChild(modal);
        });

        dialog.querySelector('#save-btn').addEventListener('click', () => {
            const strokeColor = dialog.querySelector('#stroke-color').value;
            const fillColor = dialog.querySelector('#fill-color').value;
            const opacity = dialog.querySelector('#opacity').value / 100;

            // Update rectangle properties
            rect.stroke = strokeColor;
            rect.fill = this.hexToRgba(fillColor, opacity);

            console.log('Updated rectangle properties:', rect);

            // Store selection info to restore after render
            const selectedIndex = this.selectedAnnotation ? this.selectedAnnotation.getAttribute('data-index') : null;
            const selectedType = this.selectedAnnotation ? this.selectedAnnotation.getAttribute('data-type') : null;

            this.renderER();

            // Restore selection after render
            if (selectedIndex !== null && selectedType === 'rectangle') {
                const newSelectedElement = document.querySelector(`[data-index="${selectedIndex}"][data-type="rectangle"]`);
                if (newSelectedElement) {
                    this.selectedAnnotation = newSelectedElement;
                    newSelectedElement.classList.add('selected');
                }
            }

            document.body.removeChild(modal);
        });

        // Click outside to close
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }

    editTextProperties() {
        if (!this.selectedAnnotation || !this.selectedAnnotation.classList.contains('custom-text')) return;

        const index = parseInt(this.selectedAnnotation.getAttribute('data-index'));
        const textObj = this.layoutData.texts[index];
        if (!textObj) return;

        // Create properties modal
        const modal = document.createElement('div');
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
        modal.style.zIndex = '3000';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';

        const dialog = document.createElement('div');
        dialog.style.backgroundColor = '#ffffff';
        dialog.style.padding = '20px';
        dialog.style.borderRadius = '8px';
        dialog.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
        dialog.style.minWidth = '300px';

        dialog.innerHTML = `
            <h3 style="margin: 0 0 20px 0;">テキストのプロパティ</h3>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">テキスト内容:</label>
                <input type="text" id="text-content" value="${textObj.content || ''}" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">文字色:</label>
                <input type="color" id="text-color" value="${textObj.color || '#2c3e50'}" style="width: 100%; height: 40px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px;">文字サイズ:</label>
                <input type="range" id="text-size" min="8" max="72" value="${textObj.size || 14}" style="width: 100%;">
                <span id="size-value">${textObj.size || 14}px</span>
            </div>
            <div style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; font-size: 14px; color: #666;">
                位置変更: テキストをドラッグして移動できます
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="cancel-btn" style="padding: 8px 16px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">キャンセル</button>
                <button id="save-btn" style="padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">保存</button>
            </div>
        `;

        modal.appendChild(dialog);
        document.body.appendChild(modal);

        // Size slider handler
        const sizeSlider = dialog.querySelector('#text-size');
        const sizeValue = dialog.querySelector('#size-value');
        sizeSlider.addEventListener('input', (e) => {
            sizeValue.textContent = e.target.value + 'px';
        });

        // Button handlers
        dialog.querySelector('#cancel-btn').addEventListener('click', () => {
            document.body.removeChild(modal);
        });

        dialog.querySelector('#save-btn').addEventListener('click', () => {
            const content = dialog.querySelector('#text-content').value;
            const color = dialog.querySelector('#text-color').value;
            const size = parseInt(dialog.querySelector('#text-size').value);

            // Update text properties
            textObj.content = content;
            textObj.color = color;
            textObj.size = size;

            console.log('Updated text properties:', textObj);

            // Store selection info to restore after render
            const selectedIndex = this.selectedAnnotation ? this.selectedAnnotation.getAttribute('data-index') : null;
            const selectedType = this.selectedAnnotation ? this.selectedAnnotation.getAttribute('data-type') : null;

            this.renderER();

            // Restore selection after render
            if (selectedIndex !== null && selectedType === 'text') {
                const newSelectedElement = document.querySelector(`[data-index="${selectedIndex}"][data-type="text"]`);
                if (newSelectedElement) {
                    this.selectedAnnotation = newSelectedElement;
                    newSelectedElement.classList.add('selected');
                }
            }

            document.body.removeChild(modal);
        });

        // Click outside to close
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }

    hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    extractColorFromFill(fill) {
        if (!fill) return null;
        const match = fill.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            const r = parseInt(match[1]).toString(16).padStart(2, '0');
            const g = parseInt(match[2]).toString(16).padStart(2, '0');
            const b = parseInt(match[3]).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }
        return fill;
    }

    extractOpacityFromFill(fill) {
        if (!fill) return null;
        const match = fill.match(/rgba?\([^,]+,[^,]+,[^,]+,\s*([\d.]+)\)/);
        if (match) {
            return Math.round(parseFloat(match[1]) * 100);
        }
        return null;
    }

    addResizeHandles(rectGroup, rect, index) {
        const handleSize = 6;
        const x = rect.x;
        const y = rect.y;
        const width = rect.width;
        const height = rect.height;

        // Corner handles
        const corners = [
            { x: x - handleSize/2, y: y - handleSize/2, cursor: 'nw-resize', type: 'nw' },
            { x: x + width - handleSize/2, y: y - handleSize/2, cursor: 'ne-resize', type: 'ne' },
            { x: x + width - handleSize/2, y: y + height - handleSize/2, cursor: 'se-resize', type: 'se' },
            { x: x - handleSize/2, y: y + height - handleSize/2, cursor: 'sw-resize', type: 'sw' }
        ];

        // Edge handles
        const edges = [
            { x: x + width/2 - handleSize/2, y: y - handleSize/2, cursor: 'n-resize', type: 'n' },
            { x: x + width - handleSize/2, y: y + height/2 - handleSize/2, cursor: 'e-resize', type: 'e' },
            { x: x + width/2 - handleSize/2, y: y + height - handleSize/2, cursor: 's-resize', type: 's' },
            { x: x - handleSize/2, y: y + height/2 - handleSize/2, cursor: 'w-resize', type: 'w' }
        ];

        [...corners, ...edges].forEach(handle => {
            const handleElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            handleElement.setAttribute('class', 'resize-handle');
            handleElement.setAttribute('x', handle.x);
            handleElement.setAttribute('y', handle.y);
            handleElement.setAttribute('width', handleSize);
            handleElement.setAttribute('height', handleSize);
            handleElement.setAttribute('fill', '#3498db');
            handleElement.setAttribute('stroke', '#2980b9');
            handleElement.setAttribute('stroke-width', 1);
            handleElement.setAttribute('data-handle-type', handle.type);
            handleElement.setAttribute('data-rect-index', index);
            handleElement.style.cursor = handle.cursor;
            rectGroup.appendChild(handleElement);
        });
    }

    handleResize(currentPoint) {
        const rect = this.layoutData.rectangles[this.resizeTarget.index];
        if (!rect) return;

        const handleType = this.resizeTarget.type;
        const originalRect = { ...rect };

        const minSize = 20;

        switch (handleType) {
            case 'nw':
                rect.width = Math.max(minSize, originalRect.width + (originalRect.x - currentPoint.x));
                rect.height = Math.max(minSize, originalRect.height + (originalRect.y - currentPoint.y));
                rect.x = originalRect.x + originalRect.width - rect.width;
                rect.y = originalRect.y + originalRect.height - rect.height;
                break;
            case 'ne':
                rect.width = Math.max(minSize, currentPoint.x - originalRect.x);
                rect.height = Math.max(minSize, originalRect.height + (originalRect.y - currentPoint.y));
                rect.y = originalRect.y + originalRect.height - rect.height;
                break;
            case 'se':
                rect.width = Math.max(minSize, currentPoint.x - originalRect.x);
                rect.height = Math.max(minSize, currentPoint.y - originalRect.y);
                break;
            case 'sw':
                rect.width = Math.max(minSize, originalRect.width + (originalRect.x - currentPoint.x));
                rect.height = Math.max(minSize, currentPoint.y - originalRect.y);
                rect.x = originalRect.x + originalRect.width - rect.width;
                break;
            case 'n':
                rect.height = Math.max(minSize, originalRect.height + (originalRect.y - currentPoint.y));
                rect.y = originalRect.y + originalRect.height - rect.height;
                break;
            case 'e':
                rect.width = Math.max(minSize, currentPoint.x - originalRect.x);
                break;
            case 's':
                rect.height = Math.max(minSize, currentPoint.y - originalRect.y);
                break;
            case 'w':
                rect.width = Math.max(minSize, originalRect.width + (originalRect.x - currentPoint.x));
                rect.x = originalRect.x + originalRect.width - rect.width;
                break;
        }

        this.renderER();
    }

    async showTableDetails(tableName) {
        try {
            const response = await fetch(`/api/table/${tableName}/ddl`);
            if (response.ok) {
                const data = await response.json();
                this.sidebarContent.innerHTML = `
                    <h4>${tableName}</h4>
                    <div class="ddl-content">${data.ddl}</div>
                `;
                this.sidebar.classList.add('open');
            }
        } catch (error) {
            console.error('Error loading table details:', error);
        }
    }

    closeSidebar() {
        this.sidebar.classList.remove('open');
    }

    highlightEntity(tableName) {
        const entity = document.querySelector(`[data-table="${tableName}"]`);
        if (entity) {
            // Highlight the main entity with strongest emphasis
            entity.classList.add('highlighted');
            entity.style.zIndex = '1002';
            
            // Get all relationships connected to this entity
            const relationships = document.querySelectorAll(`[data-from="${tableName}"], [data-to="${tableName}"]`);
            relationships.forEach(rel => {
                // Highlight relationship lines with enhanced effect
                rel.classList.add('highlighted');
                rel.style.zIndex = '1001';
                
                // Highlight the related entities with secondary emphasis
                const fromTable = rel.getAttribute('data-from');
                const toTable = rel.getAttribute('data-to');
                
                // Highlight the other entity in each relationship
                const relatedTable = fromTable === tableName ? toTable : fromTable;
                const relatedEntity = document.querySelector(`[data-table="${relatedTable}"]`);
                if (relatedEntity) {
                    relatedEntity.classList.add('highlighted-related');
                    relatedEntity.style.zIndex = '1000';
                }
                
                // Highlight the related columns with enhanced visibility
                const fromColumn = rel.getAttribute('data-from-column');
                const toColumn = rel.getAttribute('data-to-column');
                
                if (fromColumn) {
                    const fromColumnElement = document.querySelector(`[data-table="${fromTable}"] .column[data-column="${fromColumn}"]`);
                    if (fromColumnElement) {
                        fromColumnElement.classList.add('highlighted-column');
                    }
                }
                
                if (toColumn) {
                    const toColumnElement = document.querySelector(`[data-table="${toTable}"] .column[data-column="${toColumn}"]`);
                    if (toColumnElement) {
                        toColumnElement.classList.add('highlighted-column');
                    }
                }
            });
        }
    }

    highlightRelationshipColumns(relationshipElement) {
        const fromTable = relationshipElement.getAttribute('data-from');
        const toTable = relationshipElement.getAttribute('data-to');
        const fromColumn = relationshipElement.getAttribute('data-from-column');
        const toColumn = relationshipElement.getAttribute('data-to-column');

        // Highlight the relationship line itself with strongest emphasis
        relationshipElement.classList.add('highlighted');
        relationshipElement.style.zIndex = '1003';

        // Highlight both connected entities with strong emphasis for relationship hover
        const fromEntity = document.querySelector(`[data-table="${fromTable}"]`);
        const toEntity = document.querySelector(`[data-table="${toTable}"]`);
        
        if (fromEntity) {
            fromEntity.classList.add('highlighted-related');
            fromEntity.style.zIndex = '1002';
        }
        
        if (toEntity) {
            toEntity.classList.add('highlighted-related');
            toEntity.style.zIndex = '1002';
        }

        // Highlight the specific columns in both entities
        if (fromTable && fromColumn) {
            const fromColumnElement = document.querySelector(`[data-table="${fromTable}"] .column[data-column="${fromColumn}"]`);
            if (fromColumnElement) {
                fromColumnElement.classList.add('highlighted-column');
            }
        }

        if (toTable && toColumn) {
            const toColumnElement = document.querySelector(`[data-table="${toTable}"] .column[data-column="${toColumn}"]`);
            if (toColumnElement) {
                toColumnElement.classList.add('highlighted-column');
            }
        }
    }

    clearHighlights() {
        document.querySelectorAll('.highlighted').forEach(el => {
            el.classList.remove('highlighted');
            el.style.zIndex = '';
        });
        document.querySelectorAll('.highlighted-related').forEach(el => {
            el.classList.remove('highlighted-related');
            el.style.zIndex = '';
        });
        document.querySelectorAll('.highlighted-column').forEach(el => el.classList.remove('highlighted-column'));
    }

    addRectangle() {
        const rect = {
            x: 100,
            y: 100,
            width: 200,
            height: 100,
            stroke: '#3498db',
            fill: 'rgba(52, 152, 219, 0.1)'
        };
        this.layoutData.rectangles.push(rect);
        this.renderER();
    }

    addText() {
        const text = prompt('テキストを入力してください:');
        if (text) {
            const textObj = {
                x: 100,
                y: 100,
                content: text,
                color: '#2c3e50',
                size: 14
            };
            this.layoutData.texts.push(textObj);
            this.renderER();
        }
    }

    editText(index, textElement) {
        const textObj = this.layoutData.texts[index];
        if (!textObj) return;

        // Create an input element for inline editing
        const input = document.createElement('input');
        input.type = 'text';
        input.value = textObj.content;
        input.style.position = 'absolute';
        input.style.fontSize = textObj.size + 'px';
        input.style.color = textObj.color;
        input.style.backgroundColor = '#ffffff';
        input.style.border = '1px solid #ccc';
        input.style.padding = '2px 4px';
        input.style.zIndex = '1000';

        // Calculate position relative to the canvas
        const rect = this.canvas.getBoundingClientRect();
        const svgPoint = this.canvas.createSVGPoint();
        svgPoint.x = textObj.x;
        svgPoint.y = textObj.y;
        const screenPoint = svgPoint.matrixTransform(this.canvas.getScreenCTM());
        
        input.style.left = (rect.left + screenPoint.x) + 'px';
        input.style.top = (rect.top + screenPoint.y - textObj.size) + 'px';

        // Hide the original text element
        textElement.style.opacity = '0';

        // Add input to DOM
        document.body.appendChild(input);
        input.focus();
        input.select();

        // Handle input completion
        const finishEditing = () => {
            const newText = input.value.trim();
            if (newText && newText !== textObj.content) {
                textObj.content = newText;
                this.renderER();
            }
            textElement.style.opacity = '1';
            document.body.removeChild(input);
        };

        // Event listeners for finishing edit
        input.addEventListener('blur', finishEditing);
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                finishEditing();
            } else if (e.key === 'Escape') {
                textElement.style.opacity = '1';
                document.body.removeChild(input);
            }
        });
    }

    screenToSVG(screenX, screenY) {
        return {
            x: (screenX - this.panX) / this.scale,
            y: (screenY - this.panY) / this.scale
        };
    }

    showLoading(message, showProgress = false) {
        // Remove existing loading indicator
        this.hideLoading();
        
        const loading = document.createElement('div');
        loading.className = 'loading-overlay';
        loading.id = 'loading';
        
        const loadingContent = document.createElement('div');
        loadingContent.className = 'loading-content';
        
        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        
        const messageElement = document.createElement('div');
        messageElement.className = 'loading-message';
        messageElement.textContent = message;
        
        loadingContent.appendChild(spinner);
        loadingContent.appendChild(messageElement);
        
        if (showProgress) {
            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar';
            progressBar.id = 'progress-bar';
            
            const progressFill = document.createElement('div');
            progressFill.className = 'progress-fill';
            progressFill.id = 'progress-fill';
            
            progressBar.appendChild(progressFill);
            loadingContent.appendChild(progressBar);
        }
        
        loading.appendChild(loadingContent);
        document.body.appendChild(loading);
    }

    updateLoadingProgress(percentage, message = null) {
        const progressFill = document.getElementById('progress-fill');
        const messageElement = document.querySelector('.loading-message');
        
        if (progressFill) {
            progressFill.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
        }
        
        if (message && messageElement) {
            messageElement.textContent = message;
        }
    }

    hideLoading() {
        const loading = document.getElementById('loading');
        if (loading) {
            loading.remove();
        }
    }

    showToast(message, type = 'info', duration = 5000) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        
        const icon = document.createElement('div');
        icon.className = 'toast-icon';
        icon.textContent = this.getToastIcon(type);
        
        const messageElement = document.createElement('div');
        messageElement.className = 'toast-message';
        messageElement.textContent = message;
        
        const closeButton = document.createElement('button');
        closeButton.className = 'toast-close';
        closeButton.textContent = '×';
        closeButton.onclick = () => this.removeToast(toast);
        
        toast.appendChild(icon);
        toast.appendChild(messageElement);
        toast.appendChild(closeButton);
        
        // Add to container
        let toastContainer = document.getElementById('toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.id = 'toast-container';
            toastContainer.className = 'toast-container';
            document.body.appendChild(toastContainer);
        }
        
        toastContainer.appendChild(toast);
        
        // Auto-remove after duration
        if (duration > 0) {
            setTimeout(() => {
                this.removeToast(toast);
            }, duration);
        }
        
        return toast;
    }

    getToastIcon(type) {
        const icons = {
            success: '✓',
            error: '⚠',
            warning: '⚠',
            info: 'ℹ'
        };
        return icons[type] || icons.info;
    }

    removeToast(toast) {
        if (toast && toast.parentNode) {
            toast.classList.add('toast-removing');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }
    }

    showError(message, details = null) {
        console.error('Application Error:', message, details);
        this.showToast(message, 'error');
        
        if (details) {
            console.error('Error details:', details);
        }
    }

    showSuccess(message) {
        this.showToast(message, 'success');
    }

    showWarning(message) {
        this.showToast(message, 'warning');
    }

    async showBuildInfo() {
        const modal = document.getElementById('build-info-modal');
        const content = document.getElementById('build-info-content');
        
        try {
            content.innerHTML = '<p>ビルド情報を読み込み中...</p>';
            modal.classList.add('show');
            
            const response = await fetch('/api/build-info');
            const buildInfo = await response.json();
            
            const formatDate = (dateString) => {
                if (dateString === 'unknown' || dateString === 'ビルド情報なし') {
                    return dateString;
                }
                try {
                    const date = new Date(dateString);
                    return date.toLocaleString('ja-JP', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                } catch {
                    return dateString;
                }
            };
            
            content.innerHTML = `
                <div class="build-info-item">
                    <span class="build-info-label">アプリケーション名:</span>
                    <span class="build-info-value">${buildInfo.name}</span>
                </div>
                <div class="build-info-item">
                    <span class="build-info-label">バージョン:</span>
                    <span class="build-info-value version">${buildInfo.version}</span>
                </div>
                <div class="build-info-item">
                    <span class="build-info-label">ビルド日時:</span>
                    <span class="build-info-value">${buildInfo.buildDate || formatDate(buildInfo.buildTime)}</span>
                </div>
                <div class="build-info-item">
                    <span class="build-info-label">Git コミット:</span>
                    <span class="build-info-value commit">${buildInfo.git.commitShort}</span>
                </div>
                <div class="build-info-item">
                    <span class="build-info-label">Git ブランチ:</span>
                    <span class="build-info-value">${buildInfo.git.branch}</span>
                </div>
                ${buildInfo.git.tag ? `
                <div class="build-info-item">
                    <span class="build-info-label">Git タグ:</span>
                    <span class="build-info-value">${buildInfo.git.tag}</span>
                </div>
                ` : ''}
                <div class="build-info-item">
                    <span class="build-info-label">Node.js バージョン:</span>
                    <span class="build-info-value">${buildInfo.nodeVersion}</span>
                </div>
                <div class="build-info-item">
                    <span class="build-info-label">プラットフォーム:</span>
                    <span class="build-info-value">${buildInfo.platform} (${buildInfo.arch})</span>
                </div>
            `;
        } catch (error) {
            console.error('Error loading build info:', error);
            content.innerHTML = '<p style="color: #e74c3c;">ビルド情報の読み込みに失敗しました。</p>';
        }
    }

    hideBuildInfo() {
        const modal = document.getElementById('build-info-modal');
        modal.classList.remove('show');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new ERViewer();
});