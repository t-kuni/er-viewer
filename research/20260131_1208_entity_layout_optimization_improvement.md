## 1. 根本原因（いま起きていることの説明）

* **連結成分のパッキング未実装 + `forceCenter` の副作用**

  * 連結成分同士はリンクが無いので、force だけだと「中心付近に集まる」挙動になりやすいです（`forceCenter` があると特に）。結果として **成分どうしが同じ領域に重なって配置**されやすい。
* **矩形なのに衝突が “円近似” で弱い**

  * `forceCollide` は基本的に半径で衝突します。
  * 現状の半径 `max(w,h)/2 + 20` は、**長方形の対角半径より小さい**ことが多く、角・辺での重なりが残りやすい（＝「衝突してるのに衝突してない扱い」になりやすい）。
* **粗→詳細→最後に押し出し、の順番が “壊す”**

  * 最後の `RemoveOverlaps`（押し出し）は目的関数（リンク長・クラスタまとまり等）を見ていないので、**整えた配置を破壊**しがち。
  * 反復10回・固定ステップ押し出しは、密集時に解けない or ドリフトが増える（「解くほど崩れる」）典型です。
* **クラスタ粗レイアウトが “サイズ無しの代表点”**

  * 粗レイアウトでクラスタを点として扱うと、あとでクラスタ内を展開した瞬間に **クラスタ同士が食い込み**やすい（クラスタの実寸 bbox を考慮してない）。
* **「関連が近い」ための辺（制約）が足りない**

  * ERは疎グラフになりがちで、force は制約が弱いと “それっぽく散る” だけになります。
  * さらに名前類似を見ていないので、「関係は薄いが同系統」も寄りません。

---

## 2. d3-force パラメータ推奨（具体値と “サイズ考慮”）

前提：ノードサイズがバラつくので、固定値より **サイズから算出**した方が安定します。

### 推奨する基準量

* 各ノードの“衝突半径（円近似するなら）”は
  **`r = 0.5 * sqrt(w*w + h*h) + pad`**
  （`max(w,h)/2` は不足しやすい）
* 2ノード間の望ましい距離は
  **`d = r_source + r_target + gap`**

`pad` は 10〜20、`gap` は 20〜60 を目安。

### `forceLink`

* **関係（FK）エッジ**

  * `distance`: `rS + rT + 30`（まずこれでOK）
  * `strength`: 0.6〜1.0（疎グラフで“寄らない”なら 0.9 まで上げる）
  * `iterations`: 2（コスト増は小さく、収束が良くなる）
* **名前類似エッジ（入れるなら）**

  * `distance`: `rS + rT + (80 - 60*sim)`（sim∈[0,1]）

    * 例：sim=0.8 なら +32、sim=0.4 なら +56
  * `strength`: `0.1〜0.3`（強くし過ぎると “関係より名前が勝つ”）

### `forceManyBody`

* 現状 -300 は「小さすぎる/大きすぎる」ではなく **他の力との相対**が問題になりがちです。
* まずは “サイズ基準の距離” に合わせて：

  * **`strength = - (meanLinkDistance * 1.5)`** を起点
    （meanLinkDistance が 180 なら -270）
  * それでも成分が中心に潰れるなら、**`forceCenter` を弱める/外す**方が効きます（後述）。

### `forceCollide`

* 円でやるなら最低でも：

  * `radius`: `0.5*sqrt(w*w + h*h) + 12`
  * `iterations`: 2〜4（1だと残りやすい）
* ただし “矩形の完全非重なり” が要件なら、**円近似では限界が出ます**（3章で矩形衝突に寄せます）。

### tick 回数 / 収束条件

* 固定 200〜500 より、**alpha による打ち切り + 上限**が安定します。

  * `alphaMin`: 0.02（まずはここ）
  * 上限 tick: 400（300ノードなら多くの場合足りる）
* “段階更新”をしたいなら、50tickごとに中間送信しつつ、最後だけ alpha<alphaMin まで回すのが扱いやすいです。

---

## 3. 重なり除去の改善（押し出しをどうするか）

結論：**「最後に押し出し」から卒業**するのが最も効きます。

### 方針A（推奨）：force に矩形衝突を統合

* `RemoveOverlaps` を縮小し、代わりに

  * **矩形衝突（AABB）を解く custom force**
  * または **既存の rect-collide 系 force**
    を “常時” か “仕上げフェーズ” に入れる。
* メリット

  * 目的（リンク・クラスタ）とトレードオフしながら解けるので **崩れにくい**
* デメリット

  * 実装は少し増える（ただし300ノードなら quadtree で十分間に合う）

### 方針B：押し出し方式を残すなら（最低限の改善）

* 反復回数：10 → **30〜80**
* 押し出しマージン：+5 → **+12〜+20**
* 押し出し量：固定ではなく **重なり量に比例**（overlapX/overlapY の半分ずつ移動）
* 崩れ防止：

  * 押し出し前の座標 `p0` を保存し、押し出し後に
    **`x += (p0.x - x) * k`**（k=0.05〜0.15）みたいな弱い復元を入れる
    → “押し出しで散っただけ” を抑えられます

### ELK の Overlap Removal を使うべきか

* “矩形非重なりを確実にしたい” なら有効です。
* ただし **いまの構造（forceで作って最後にELKで直す）だと崩れ**が出やすいので、使うなら

  * **「仕上げ」ではなく「拘束」として挿す**（＝ELKをメインに寄せる）
  * もしくは **成分単位のpacking**用途に限定
    が無難です。

---

## 4. 名前類似度を反映する実装（A/B/Cの比較と推奨）

### 類似度計算（2-gram + Jaccard はOKか）

* snake_case（`post_groups` 等）には相性が良いので **採用してOK**。
* ただしテーブル名は構造が見えているので、実務的には **token（`_`分割）Jaccard** を先に入れると安定します。

  * 例：`post_approval_histories` と `post_scheduled` は 2-gram だとそこそこ近く出やすいが、token だと “post” 共有として自然に扱える
* おすすめ（軽い・実装容易・精度も出る）：

  * 正規化：小文字化、連続`_`整理、語尾の`s`の単純除去（雑でOK）、`tbl_`等の既知prefix除去（任意）
  * **score = 0.6 * tokenJaccard + 0.4 * bigramJaccard**

### 閾値（“似ている”判定）

* 固定閾値一本より、**上位k件採用**が安定します（密度が変わるため）。

  * 推奨：各ノードにつき **top-k（k=3〜5）** を追加
  * ただし `score < 0.35` は切る（ノイズが増えやすい）
* 300ノードの全ペア（約45k）でも計算は可能ですが、top-kにするとエッジ爆発を防げます。

---

### パターンA：仮想エッジ追加（推奨）

* 方式

  * `RelationshipEdge` に加えて `SimilarityEdge` を追加し、`forceLink` に渡す
  * エッジ種別で `distance/strength` を変える
* メリット

  * 実装が最短、d3-forceの枠内で完結
  * チューニングが直感的（強さを下げれば影響減）
* デメリット

  * 追加エッジが多いと収束が遅くなる（top-kで回避）

### パターンB：カスタム力（次点）

* 方式

  * `force('similarity', ...)` で、似ているペアに引力（ばね）を入れる
* メリット

  * “近づけたいがリンクとしては扱いたくない” を作りやすい
* デメリット

  * 実装・デバッグが増える割に、Aで代替できることが多い

### パターンC：クラスタリングへ反映（非推奨）

* 方式

  * Louvain の重み付き辺として similarity を入れる
* メリット

  * クラスタ境界に反映できる
* デメリット

  * **クラスタが“名前”で汚染**されやすい（関係構造より名前が勝つ）
  * その後の詳細配置で結局また調整が必要

→ 結論：まず **A（仮想エッジ）**、次に必要なら B。

---

## 5. 仕様の明確化（“など” を消して確定させる）

### クラスタリング

* **Louvain を採用で固定**でよい（graphology ですでに整備済み）
* パラメータは仕様に明記（例）

  * 入力グラフ：実リレーションのみ（名前類似は使わない）
  * 重み：全て1（まずは）
  * 解像度（resolution）を使うなら、MVPは固定 1.0（触るのは後）

### レイアウト

* **d3-force を採用で固定**（現状の延長で改善が出る）
* 追加で明記する点

  * “矩形衝突は円近似ではなく、矩形対応 force を使う（または自前）”
  * リンク距離は固定値ではなく “サイズ由来”
  * 連結成分は packing する（未実装の穴を塞ぐ）

### 重なり除去

* 仕様としては

  * 第一選択：force内の矩形衝突
  * 最終保険：軽量な post-process（反復小さめ）
    を明記しておくと実装がブレません。

### forceatlas2 / ELK

* forceatlas2 は “品質”よりも “見た目の好み” に寄ることが多く、矩形サイズも見ません。
* ELKは体系的ですが重くなりがちなので、MVPで “確実に交差を減らす/直交配線する” が欲しくなった時に導入判断でよいです。

---

## 6. 多段階アプローチの見直し（どれが効くか）

一番効くのは **「成分ごとに完成 → 成分を詰める」**です。

### 推奨：パターンB（少し改造版）

1. 実リレーションのみで connected components
2. 各成分内で（実リレーション + 類似エッジ）を使って d3-force

   * ここで **矩形衝突も統合**
3. 各成分の bbox を計算
4. 成分 bbox を packing（段階6を実装）
5. 必要なら全体で短い “仕上げ” （衝突だけ強め、リンク弱め）

この構成だと

* “関連が近い” が成分内で出る
* “成分同士が重なる” が packing で消える
* “最後の押し出しで崩れる” がほぼ無くなる

---

## 7. ライブラリ決定（MVPとしての推奨）

* **採用：d3-force + graphology(+Louvain/components)**

  * すでに実装があるので改善効率が最大
* **追加：矩形衝突のための実装（どちらか）**

  * (推奨) 自前の `rectCollide` force（quadtreeで近傍だけ見る）
  * もしくは npm の rect-collide 系（導入するなら仕様に “これ” と明記）
* **保留：graphology-layout-forceatlas2**

  * 使うなら “粗レイアウト” の置き換え用途だが、今の根本（成分packing/矩形衝突）を解決しない
* **保留：elkjs**

  * “直交配線・交差最小・整列” に踏み込む段階で検討

---

## 8. 300ノード/10秒の見積もりとボトルネック

* connected components / Louvain：300規模なら軽い（体感は誤差）
* ボトルネック候補

  * d3-force の tick 数（特にエッジが増えた時）
  * O(n^2) の名前類似計算（ただし 45k 程度なので許容、実装次第）
  * “押し出し反復” を増やし過ぎるとここが支配的になる

パフォーマンス施策（効く順）

* 類似エッジは **top-k + 閾値**で制限（エッジ爆発を止める）
* tick は **alpha 打ち切り + 上限**で制限
* 矩形衝突は **近傍探索（quadtree / spatial hash）必須**（全ペア禁止）
* 成分ごとに回す（小さいグラフを複数回す方が収束が速いことが多い）

---

## 9. 段階的な実装計画

### フェーズ1（効果最大・即実装）

* 段階6：**連結成分のパッキング**を実装（未実装の穴を塞ぐ）
* `forceCollide` 半径を **対角ベース**に変更（最低限の改善）
* `forceLink.distance` を **サイズ由来**に変更（固定150を撤廃）
* 類似エッジ：**top-k + 閾値**で仮想エッジ追加（パターンA）

### フェーズ2（次に効く）

* `RemoveOverlaps` を縮小し、**矩形衝突 force を導入**（自前 or ライブラリ）
* “粗→詳細”を整理：

  * 成分内だけで完結するならクラスタ粗レイアウトを省略して、まず安定させる
  * クラスタを残すなら、粗レイアウトはクラスタ bbox をサイズとして扱う

### フェーズ3（高度化）

* 交差削減・整列・直交配線まで踏み込むなら elkjs 検討
* 位置の安定性（同じ入力で似た配置）を上げるなら

  * 初期値を前回座標に寄せる
  * “固定ノード/ピン留め”の導入（ユーザーが動かした位置を尊重）

---
