/**
 * ER Viewer Application E2E Style Tests
 * モックされたインフラストラクチャーを使用してアプリケーション全体をテスト
 */
import { ERViewerApplication } from '../public/js/er-viewer-application';
import { InfrastructureMock } from '../public/js/infrastructure/mocks/infrastructure-mock';
import type { MockData } from '../public/js/types/infrastructure';
import { MockElement } from '../public/js/infrastructure/mocks/dom-mock';
import { NetworkMock } from '../public/js/infrastructure/mocks/network-mock';
import type { ERData, LayoutData } from '../public/js/types/index';

interface MockERData extends ERData {
  layout: LayoutData;
}

interface NetworkResponse<T = any> {
  status: number;
  statusText?: string;
  data?: T;
}

interface DDLResponse {
  ddl: string;
}

// テスト用タイプ

describe('ERViewerApplication E2E Tests', () => {
  let app: any; // Using any to access private methods for testing
  let infrastructure: InfrastructureMock;

  beforeEach(() => {
    // モックインフラストラクチャーを作成
    infrastructure = new InfrastructureMock();

    // 基本的なモックデータの設定（個別のテストケースでオーバーライドされる）
    const mockData: MockData = {
      networkResponses: {
        // 初期化時に必要な最小限のERデータ
        '/api/er-data': {
          status: 200,
          data: {
            entities: [],
            relationships: [],
            layout: {
              entities: {},
              rectangles: [],
              texts: [],
              layers: [],
            },
          },
        } as NetworkResponse<MockERData>,
        '/api/table/users/ddl': {
          status: 200,
          data: { ddl: 'CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255), email VARCHAR(255) UNIQUE);' },
        } as NetworkResponse<DDLResponse>,
        '/api/layout': {
          status: 200,
          data: { success: true },
        } as NetworkResponse<{ success: boolean }>,
      },
      promptResponses: ['テストテキスト'],
      confirmResponses: [true],
    };

    infrastructure.setupMockData(mockData);

    // アプリケーションを初期化（各テストケースでERデータを設定）
    app = new ERViewerApplication(infrastructure);
  });

  afterEach(() => {
    infrastructure.clearHistory();
  });

  describe('初期化', () => {
    test('アプリケーションが正常に初期化される', () => {
      // Arrange
      // beforeEachで infrastructure と app が初期化済み

      // Act
      // コンストラクタによる初期化は beforeEach で実行済み

      // Assert
      expect(app).toBeDefined();
      expect(app.state).toBeDefined();
      expect(app.state.canvas).toBeDefined();
      expect(app.state.sidebar).toBeDefined();
    });

    test('初期データがロードされる', async () => {
      // Arrange
      const testERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'name', type: 'varchar(255)', key: '', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
          {
            name: 'posts',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'title', type: 'varchar(255)', key: '', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [],
        layout: {
          entities: {},
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: testERData,
      });

      // Act
      await app.loadERData();

      // Assert
      const history = infrastructure.getInteractionHistory();
      const requests = history.networkRequests;

      expect(requests.some((req) => req.url === '/api/er-data')).toBe(true);
      expect(app.state.erData).toBeDefined();
      expect(app.state.erData?.entities).toHaveLength(2);
    });

    test('キャンバスが正しく初期化される', () => {
      // Arrange
      // beforeEachで infrastructure と app が初期化済み

      // Act
      const canvas = infrastructure.dom.getElementById('er-canvas') as unknown as MockElement;

      // Assert
      expect(canvas).toBeDefined();
      expect(canvas.getAttribute('width')).toBe('800');
      expect(canvas.getAttribute('height')).toBe('600');
    });
  });

  describe('エンティティの表示', () => {
    beforeEach(async () => {
      // 初期化を待つ
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    test('エンティティが正しく描画される', async () => {
      // Arrange
      const renderERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'name', type: 'varchar(255)', key: '', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
          {
            name: 'posts',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'title', type: 'varchar(255)', key: '', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
            posts: { position: { x: 350, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: renderERData,
      });

      // Act
      // データを再ロードしてからレンダリング
      await app.loadERData();
      app.render();

      // Assert
      // エンティティがキャンバスに描画されることを確認
      const dynamicLayer = infrastructure.dom.getElementById('dynamic-layer') as unknown as MockElement;
      expect(dynamicLayer).toBeDefined();

      // エンティティ要素が作成されることを確認
      const entityElements = dynamicLayer.children.filter(
        (child: MockElement) => child.getAttribute && child.getAttribute('class') === 'entity draggable',
      );
      expect(entityElements.length).toBeGreaterThan(0);
    });

    test('エンティティクリックでテーブル詳細が表示される', async () => {
      // Arrange
      const clickERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'email', type: 'varchar(255)', key: 'UNI', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: clickERData,
      });

      await app.loadERData();
      app.render();

      // Act
      // usersエンティティをクリック
      app.showTableDetails('users');

      // ネットワークリクエストが送信されることを確認
      await new Promise((resolve) => setTimeout(resolve, 0));

      // Assert
      const history = infrastructure.getInteractionHistory();
      const requests = history.networkRequests;

      expect(requests.some((req) => req.url === '/api/table/users/ddl')).toBe(true);
      expect(app.state.sidebarVisible).toBe(true);
      expect(app.state.currentTable).toBe('users');
    });

    test('リレーションシップが正しく描画される - dynamicLayer.children.filter エラー修正', async () => {
      // Arrange
      const relationshipERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
          {
            name: 'posts',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'user_id', type: 'int', key: 'MUL', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [
          {
            from: 'posts',
            fromColumn: 'user_id',
            to: 'users',
            toColumn: 'id',
            constraintName: 'posts_user_id_fkey',
          },
        ],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
            posts: { position: { x: 350, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: relationshipERData,
      });

      // Act
      await app.loadERData();
      app.render();

      // Assert
      // エンティティがレンダリングされていることを確認
      const dynamicLayer = infrastructure.dom.getElementById('dynamic-layer') as unknown as MockElement;
      expect(dynamicLayer).toBeDefined();

      // dynamicLayer.children.filter is not a function エラーが発生しないことを確認
      expect(() => {
        app.renderRelationships();
      }).not.toThrow();

      // リレーションシップグループが存在することを確認
      // dynamicLayer.children が HTMLCollection または NodeList の場合、
      // Array.from() を使用して配列に変換する必要がある
      const childrenArray = Array.from(dynamicLayer.children);
      const relationshipGroups = childrenArray.filter(
        (child: MockElement) => child.getAttribute && child.getAttribute('class') === 'relationships',
      );
      expect(relationshipGroups.length).toBeGreaterThan(0);

      // 具体的なリレーションシップパスが存在することを確認
      const relationshipGroup = relationshipGroups[0];
      const pathElements = relationshipGroup
        ? Array.from(relationshipGroup.children).filter(
            (child: MockElement) => child.tagName === 'path' && child.getAttribute('class') === 'relationship',
          )
        : [];
      expect(pathElements.length).toBeGreaterThan(0);

      // パスにデータ属性が設定されていることを確認
      const firstPath = pathElements[0] as MockElement;
      expect(firstPath.getAttribute('data-from-table')).toBe('posts');
      expect(firstPath.getAttribute('data-to-table')).toBe('users');
    });

    test('エンティティバウンドが正しく設定される', async () => {
      // Arrange
      const boundsERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'name', type: 'varchar(255)', key: '', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
          {
            name: 'posts',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'title', type: 'varchar(255)', key: '', nullable: false, default: null, extra: '' },
              { name: 'user_id', type: 'int', key: 'MUL', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
            posts: { position: { x: 350, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: boundsERData,
      });

      // Act
      await app.loadERData();
      app.render();

      // Assert
      // エンティティバウンドが設定されていることを確認
      expect(app.state.entityBounds.has('users')).toBe(true);
      expect(app.state.entityBounds.has('posts')).toBe(true);

      const usersBounds = app.state.entityBounds.get('users');
      expect(usersBounds).toBeDefined();
      expect(usersBounds?.x).toBeDefined();
      expect(usersBounds?.y).toBeDefined();
      expect(usersBounds?.width).toBeDefined();
      expect(usersBounds?.height).toBeDefined();
    });

    test('リレーションシップレンダリングの詳細検証', async () => {
      // Arrange
      const detailERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
          {
            name: 'posts',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'user_id', type: 'int', key: 'MUL', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [
          {
            from: 'posts',
            fromColumn: 'user_id',
            to: 'users',
            toColumn: 'id',
            constraintName: 'posts_user_id_fkey',
          },
        ],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
            posts: { position: { x: 350, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: detailERData,
      });

      // データをロードして状態を更新
      await app.loadERData();
      
      // ERデータにリレーションシップが含まれていることを確認
      expect(app.state.erData?.relationships).toBeDefined();
      expect(app.state.erData?.relationships?.length).toBe(1);

      const relationship = app.state.erData?.relationships?.[0];
      expect(relationship?.from).toBe('posts');
      expect(relationship?.to).toBe('users');

      // Act
      app.render();

      // Assert
      // dynamic-layerの内容を詳細確認
      const dynamicLayer = infrastructure.dom.getElementById('dynamic-layer') as unknown as MockElement;
      console.log('Dynamic layer children count:', dynamicLayer.children.length);

      // 各子要素をチェック
      dynamicLayer.children.forEach((child: MockElement, index: number) => {
        console.log(`Child ${index}:`, {
          tagName: child.tagName,
          className: child.getAttribute('class'),
          id: child.getAttribute('id'),
        });
      });

      // relationshipsグループが正しく挿入されているか確認
      const relationshipGroups = dynamicLayer.children.filter(
        (child: MockElement) => child.getAttribute && child.getAttribute('class') === 'relationships',
      );

      if (relationshipGroups.length === 0) {
        console.log('No relationship groups found');
        console.log(
          'Available children classes:',
          dynamicLayer.children.map((child: MockElement) => child.getAttribute('class')),
        );
      }

      expect(relationshipGroups.length).toBeGreaterThan(0);
    });

    test('リレーションシップパスの座標が正しく計算される', async () => {
      // Arrange
      const pathERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'name', type: 'varchar(255)', key: '', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
          {
            name: 'posts',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'title', type: 'varchar(255)', key: '', nullable: false, default: null, extra: '' },
              { name: 'content', type: 'text', key: '', nullable: false, default: null, extra: '' },
              { name: 'user_id', type: 'int', key: 'MUL', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [
          {
            from: 'posts',
            fromColumn: 'user_id',
            to: 'users',
            toColumn: 'id',
            constraintName: 'posts_user_id_fkey',
          },
        ],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
            posts: { position: { x: 350, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: pathERData,
      });

      // Act
      await app.loadERData();
      app.render();

      // Assert
      // エンティティバウンドを確認
      const usersBounds = app.state.entityBounds.get('users');
      const postsBounds = app.state.entityBounds.get('posts');

      console.log('Users bounds:', usersBounds);
      console.log('Posts bounds:', postsBounds);

      // リレーションシップパスのd属性を確認
      const dynamicLayer = infrastructure.dom.getElementById('dynamic-layer') as unknown as MockElement;
      const relationshipGroups = dynamicLayer.children.filter(
        (child: MockElement) => child.getAttribute && child.getAttribute('class') === 'relationships',
      );

      expect(relationshipGroups.length).toBe(1);

      const relationshipGroup = relationshipGroups[0];
      const pathElements = relationshipGroup
        ? relationshipGroup.children.filter(
            (child: MockElement) => child.tagName === 'path' && child.getAttribute('class') === 'relationship',
          )
        : [];

      expect(pathElements.length).toBe(1);

      const path = pathElements[0] as MockElement;
      const dAttribute = path.getAttribute('d');
      expect(dAttribute).toBeDefined();

      // パスが有効な座標を持っているか確認
      expect(dAttribute).toMatch(/^M [\d.]+\s+[\d.]+\s+L\s+[\d.]+\s+[\d.]+$/);
      expect(path.getAttribute('stroke')).toBe('#666');
      expect(path.getAttribute('stroke-width')).toBe('2');
    });
  });

  describe('エンティティのドラッグ操作', () => {
    beforeEach(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
      app.render();
    });

    test('エンティティをドラッグできる', async () => {
      // Arrange
      const dragERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: dragERData,
      });

      await app.loadERData();
      app.render();

      const dynamicLayer = infrastructure.dom.getElementById('dynamic-layer') as unknown as MockElement;
      const userEntity = dynamicLayer.children.find(
        (child: MockElement) => child.getAttribute && child.getAttribute('data-table-name') === 'users',
      ) as MockElement;
      expect(userEntity).toBeDefined();
      const dragStartPosition = { x: 150, y: 150 };

      // Act
      app.startEntityDrag(userEntity as unknown as Element, dragStartPosition);

      // Assert
      expect(app.state.interactionMode).toBe('dragging');
      expect(app.state.dragState).toBeDefined();
      expect(app.state.dragState?.type).toBe('entity');
      expect(app.state.dragState?.tableName).toBe('users');
    });

    test('エンティティドラッグでレイアウトが更新される', async () => {
      // Arrange
      const dragUpdateERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 200,
        data: dragUpdateERData,
      });

      await app.loadERData();
      app.render();

      const dynamicLayer = infrastructure.dom.getElementById('dynamic-layer') as unknown as MockElement;
      const userEntity = dynamicLayer.children.find(
        (child: MockElement) => child.getAttribute && child.getAttribute('data-table-name') === 'users',
      ) as MockElement;
      const dragStartPosition = { x: 100, y: 100 };
      const mockMouseMoveEvent = {
        clientX: 250,
        clientY: 250,
      } as MouseEvent;

      // Act
      app.startEntityDrag(userEntity as unknown as Element, dragStartPosition);
      app.updateDrag(mockMouseMoveEvent);
      app.endInteraction();

      // Assert
      expect(app.state.layoutData.entities.users).toBeDefined();
    });
  });

  describe('注釈機能', () => {
    beforeEach(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    test('矩形注釈を追加できる', () => {
      // Arrange
      const initialRectCount = app.state.layoutData.rectangles.length;
      const xPosition = 200;
      const yPosition = 200;

      // Act
      app.addRectangleAtPosition(xPosition, yPosition);

      // Assert
      expect(app.state.layoutData.rectangles.length).toBe(initialRectCount + 1);
      const newRect = app.state.layoutData.rectangles[app.state.layoutData.rectangles.length - 1];
      expect(newRect.x).toBe(200);
      expect(newRect.y).toBe(200);
      expect(newRect.width).toBe(100);
      expect(newRect.height).toBe(60);
    });

    test('テキスト注釈を追加できる', () => {
      // Arrange
      const initialTextCount = app.state.layoutData.texts.length;
      const xPosition = 300;
      const yPosition = 300;
      // mockERDataのpromptResponsesには'テストテキスト'が設定されている

      // Act
      app.addTextAtPosition(xPosition, yPosition);

      // Assert
      expect(app.state.layoutData.texts.length).toBe(initialTextCount + 1);
      const newText = app.state.layoutData.texts[app.state.layoutData.texts.length - 1];
      expect(newText.x).toBe(300);
      expect(newText.y).toBe(300);
      expect(newText.content).toBe('テストテキスト');
    });
  });

  describe('ビューポート操作', () => {
    beforeEach(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    test('パン操作でビューポートが更新される', () => {
      // Arrange
      const initialPanX = app.state.viewport.panX;
      const initialPanY = app.state.viewport.panY;
      const startX = 100;
      const startY = 100;
      const mockEvent = {
        clientX: 150,
        clientY: 150,
      } as MouseEvent;

      // Act
      app.startPan(startX, startY);
      app.updatePan(mockEvent);

      // Assert
      expect(app.state.viewport.panX).toBe(initialPanX + 50);
      expect(app.state.viewport.panY).toBe(initialPanY + 50);
    });

    test('ズーム操作でスケールが更新される', () => {
      // Arrange
      const initialScale = app.state.viewport.scale;
      const mockWheelEvent = {
        preventDefault: jest.fn(),
        clientX: 400,
        clientY: 300,
        deltaY: -100,
      } as unknown as WheelEvent;

      // Act
      app.handleCanvasWheel(mockWheelEvent);

      // Assert
      expect(app.state.viewport.scale).toBeGreaterThan(initialScale);
      expect((mockWheelEvent as any).preventDefault).toHaveBeenCalled();
    });
  });

  describe('データ永続化', () => {
    beforeEach(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    test('レイアウト保存が正常に動作する', async () => {
      await app.saveLayout();

      const history = infrastructure.getInteractionHistory();
      const requests = history.networkRequests;

      expect(requests.some((req) => req.url === '/api/layout')).toBe(true);
    });

    test('リバースエンジニアリングが正常に動作する', async () => {
      // Arrange
      const reverseERData: MockERData = {
        entities: [
          {
            name: 'users',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'email', type: 'varchar(255)', key: 'UNI', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
          {
            name: 'posts',
            columns: [
              { name: 'id', type: 'int', key: 'PRI', nullable: false, default: null, extra: '' },
              { name: 'user_id', type: 'int', key: 'MUL', nullable: false, default: null, extra: '' },
            ],
            foreignKeys: [],
            ddl: '',
          },
        ],
        relationships: [
          {
            from: 'posts',
            fromColumn: 'user_id',
            to: 'users',
            toColumn: 'id',
            constraintName: 'posts_user_id_fkey',
          },
        ],
        layout: {
          entities: {
            users: { position: { x: 100, y: 100 } },
            posts: { position: { x: 350, y: 100 } },
          },
          rectangles: [],
          texts: [],
          layers: [],
        },
      };

      (infrastructure.network as NetworkMock).setMockResponse('/api/reverse-engineer', {
        status: 200,
        data: reverseERData,
      });

      // Act
      await app.reverseEngineer();

      // Assert
      const history = infrastructure.getInteractionHistory();
      const requests = history.networkRequests;

      expect(requests.some((req) => req.url === '/api/reverse-engineer')).toBe(true);
    });
  });

  describe('UI操作', () => {
    beforeEach(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    test('サイドバーの開閉が正常に動作する', async () => {
      // サイドバーを開く
      await app.showTableDetails('users');
      expect(app.state.sidebarVisible).toBe(true);

      // サイドバーを閉じる
      app.closeSidebar();
      expect(app.state.sidebarVisible).toBe(false);
    });

    test('コンテキストメニューが表示される', () => {
      app.showContextMenu(200, 200, { x: 100, y: 100 }, null);

      expect(app.state.contextMenu).toBeDefined();

      app.hideContextMenu();

      expect(app.state.contextMenu).toBeNull();
    });

    test('ローディング表示が正常に動作する', () => {
      app.showLoading('テスト中...');

      const loadingElement = infrastructure.dom.getElementById('loading-overlay');
      expect(loadingElement).toBeDefined();
      expect(loadingElement?.textContent).toBe('テスト中...');

      app.hideLoading();

      const removedElement = infrastructure.dom.getElementById('loading-overlay');
      expect(removedElement).toBeNull();
    });
  });

  describe('状態管理', () => {
    test('状態の変更が正しく通知される', () => {
      const subscriber = jest.fn();
      app.subscribe(subscriber);

      const newViewport = { panX: 10, panY: 20, scale: 1.5 };
      app.setState({ viewport: newViewport });

      expect(subscriber).toHaveBeenCalled();
      expect(app.state.viewport).toEqual(newViewport);
    });

    test('プロパティ変更の監視が正常に動作する', () => {
      const propertySubscriber = jest.fn();
      app.subscribeToProperty('viewport', propertySubscriber);

      const oldViewport = app.state.viewport;
      const newViewport = { panX: 100, panY: 100, scale: 2 };

      app.setState({ viewport: newViewport });

      expect(propertySubscriber).toHaveBeenCalledWith(oldViewport, newViewport);
    });

    test('ヒストリー機能が正常に動作する', () => {
      const initialHistoryLength = app.state.history.length;

      // レイアウトデータを変更（ヒストリーに保存される）
      app.setState({ layoutData: { entities: {}, rectangles: [], texts: [], layers: [] } });

      expect(app.state.history.length).toBeGreaterThan(initialHistoryLength);
    });
  });

  describe('エラーハンドリング', () => {
    test('ネットワークエラーが適切に処理される', async () => {
      // エラーレスポンスを設定
      (infrastructure.network as NetworkMock).setMockResponse('/api/er-data', {
        status: 500,
        statusText: 'Internal Server Error',
      });

      await app.loadERData();

      expect(app.state.error).toBeDefined();
      expect(app.state.loading).toBe(false);
    });

    test('無効なテーブル名でのDDL取得エラーが処理される', async () => {
      infrastructure.setupMockData({
        networkResponses: {
          '/api/table/invalid/ddl': {
            status: 404,
            statusText: 'Not Found',
          },
        },
      });

      await app.showTableDetails('invalid');

      const history = infrastructure.getInteractionHistory();
      expect(history.errors.length).toBeGreaterThan(0);
    });
  });
});
